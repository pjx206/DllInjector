#include "Image.h"
#include <Shlwapi.h>
#include <stdio.h>

#pragma comment(lib, "shlwapi.lib")

CImage::CImage()
{
    m_hFile = INVALID_HANDLE_VALUE;
    m_hModule = NULL;
    m_pDosHeader = NULL;
    m_pFileHeader = NULL;
    m_pRelocTable = NULL;
    m_pSecHeader = NULL;
    m_pExportDir = NULL;
    m_pImportDesp = NULL;
    m_pOptHeader = NULL;

    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    m_dwPageSize = sysinfo.dwPageSize;
}

CImage::~CImage()
{
    Cleanup();
}

PBYTE CImage::LoadImage(HANDLE hFile, BOOL bDoReloc, ULONG_PTR RelocBase, BOOL bDoImport)
{
    DWORD dwFileSize = 0;
    BOOL bResult = FALSE;
    DWORD dwNumOfBytesRead;
    PIMAGE_SECTION_HEADER pTmpSecHeader = NULL;
    BYTE *pMemory = NULL;
    __try
    {
        m_hFile = hFile;
        dwFileSize = GetFileSize(m_hFile, NULL);
        if (dwFileSize == 0)
        {
            strcpy(m_szErrorMsg, "文件大小为0!"); // TODO: 把FormatErrorMsg()重构下，避免两种错误信息构造方式
            __leave;
        }

        DWORD dwSizeToRead = (dwFileSize > PEHEADER_SIZE) ? PEHEADER_SIZE : dwFileSize;
        ZeroMemory(m_HeaderData, PEHEADER_SIZE);
        bResult = ReadFile(m_hFile, m_HeaderData, dwSizeToRead, &dwNumOfBytesRead, NULL);
        if (!bResult)
        {
            FormatErrorMsg("读取文件失败", GetLastError());
            __leave;
        }

        if (!VerifyImage(m_HeaderData))
        {
            strcpy(m_szErrorMsg, "不是有效的PE映像");
            __leave;
        }

        InitializePEHeaders(m_HeaderData);

        pTmpSecHeader = m_pSecHeader;

        pMemory = m_hModule = (BYTE *)VirtualAlloc(NULL, m_TotalImageSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if (m_hModule == NULL)
        {
            strcpy(m_szErrorMsg, "内存不足，为保存PE头数据申请内存失败");
            __leave;
        }

        memcpy(pMemory, m_HeaderData, m_pOptHeader->SizeOfHeaders);
        pMemory += GetAlignedSize(m_pOptHeader->SizeOfHeaders, m_pOptHeader->SectionAlignment);

        LARGE_INTEGER liFileOffset;
        for (int i = 0; i < m_SectionCnt; i++)
        {
            liFileOffset.QuadPart = pTmpSecHeader->PointerToRawData;
            bResult = SetFilePointerEx(m_hFile, liFileOffset, NULL, FILE_BEGIN);
            if (!bResult)
            {
                FormatErrorMsg("设置文件读写位置失败!", GetLastError());
                __leave;
            }

            //读取各个节
            bResult = ReadFile(m_hFile, pMemory, pTmpSecHeader->SizeOfRawData, &dwNumOfBytesRead, NULL);
            if (!bResult)
            {
                FormatErrorMsg("读取文件失败!", GetLastError());
                __leave;
            }
            pMemory += GetAlignedSize(pTmpSecHeader->Misc.VirtualSize, m_pOptHeader->SectionAlignment);
            pTmpSecHeader++;
        }

        //重新解析PE头
        InitializePEHeaders(m_hModule);

        //开始处理重定位数据
        if (bDoReloc)
        {
            //如果RelocBase为0，则按实际加载位置进行重定位
            ULONG_PTR BaseToReloc = (RelocBase == 0) ? (DWORD)m_hModule : RelocBase;
            ProcessRelocTable(BaseToReloc);
        }

        //处理导入表
        if (bDoImport)
        {
            ProcessImportTable();
        }

        bResult = TRUE; //加载成功
    }
    __finally
    {
        if (!bResult)
        {
            if (m_hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(m_hFile);
                m_hFile = INVALID_HANDLE_VALUE;
            }
        }
    }

    return m_hModule;
}

//以文件路径方式打开PE
PBYTE CImage::LoadImage(char *szPEPath, BOOL bDoReloc, ULONG_PTR RelocBase, BOOL bDoImport)
{
    //保存PE路径
    strcpy(m_szPEPath, szPEPath);
    //以只读方式打开文件
    m_hFile = CreateFileA(szPEPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        FormatErrorMsg("打开文件失败!", GetLastError());
        return NULL;
    }

    return LoadImage(m_hFile, bDoReloc, RelocBase, bDoImport);
}

VOID CImage::FreePE()
{
    VirtualFree(m_hModule, 0, MEM_RELEASE);
    m_hModule = NULL;
}

DWORD CImage::GetAlignedSize(DWORD theSize, DWORD Alignment)
{
    // 把获取对齐大小的宏封装给CImage类用
    DWORD dwAlignedVirtualSize = 0;
    dwAlignedVirtualSize = ALIGN_SIZE_UP(theSize, Alignment);
    return dwAlignedVirtualSize; //返回对齐后的大小
}

ULONG_PTR CImage::GetAlignedPointer(ULONG_PTR uPointer, DWORD Alignment)
{
    DWORD dwAlignedAddress = 0;
    dwAlignedAddress = ALIGN_SIZE_UP(uPointer, Alignment);
    return dwAlignedAddress; //返回对齐后的大小
}

DWORD CImage::_GetProcAddress(PBYTE pModule, char *szFuncName)
{
    //自己实现GetProcAddress
    DWORD retAddr = 0;
    DWORD *namerav, *funrav;
    DWORD cnt = 0;
    DWORD max, min, mid;
    WORD *nameOrdinal;
    WORD nIndex = 0;
    int cmpresult = 0;
    char *ModuleBase = (char *)pModule;
    char *szMidName = NULL;
    PIMAGE_DOS_HEADER pDosHeader;
    PIMAGE_NT_HEADERS pNtHeader;
    PIMAGE_OPTIONAL_HEADER pOptHeader;
    PIMAGE_EXPORT_DIRECTORY pExportDir;

    if (ModuleBase == NULL)
    {
        return 0;
    }

    pDosHeader = (PIMAGE_DOS_HEADER)ModuleBase;
    if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
    {
        return 0;
    }
    pNtHeader = (PIMAGE_NT_HEADERS)(ModuleBase + pDosHeader->e_lfanew);
    if (pNtHeader->Signature != IMAGE_NT_SIGNATURE)
    {
        return 0;
    }

    pOptHeader = &pNtHeader->OptionalHeader;
    pExportDir = (PIMAGE_EXPORT_DIRECTORY)(ModuleBase + pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    namerav = (DWORD *)(ModuleBase + pExportDir->AddressOfNames);
    funrav = (DWORD *)(ModuleBase + pExportDir->AddressOfFunctions);
    nameOrdinal = (WORD *)(ModuleBase + pExportDir->AddressOfNameOrdinals);

    if ((DWORD)szFuncName < 0x0000FFFF)
    {
        retAddr = (DWORD)(ModuleBase + funrav[(WORD)szFuncName]);
    }
    else
    {
        //二分法查找
        max = pExportDir->NumberOfNames;
        min = 0;
        mid = (max + min) / 2;
        while (min < max)
        {
            szMidName = ModuleBase + namerav[mid];
            cmpresult = strcmp(szFuncName, szMidName);
            if (cmpresult < 0)
            {
                //比中值小,则取中值-1为最大值
                max = mid - 1;
            }
            else if (cmpresult > 0)
            {
                //比中值大,则取中值+1为最小值
                min = mid + 1;
            }
            else
            {
                break;
            }
            mid = (max + min) / 2;
        }

        if (strcmp(szFuncName, ModuleBase + namerav[mid]) == 0)
        {
            nIndex = nameOrdinal[mid];
            retAddr = (DWORD)(ModuleBase + funrav[nIndex]);
        }
    }
    return retAddr;
}

DWORD CImage::GetTotalImageSize(DWORD Alignment)
{
    // Alignment对齐下，映像大小
    DWORD TotalSize = 0;
    DWORD tmp = 0;
    PIMAGE_SECTION_HEADER pTmpSecHeader = m_pSecHeader;
    TotalSize += GetAlignedSize(m_pOptHeader->SizeOfHeaders, Alignment);
    for (WORD i = 0; i < m_SectionCnt; i++)
    {
        tmp = GetAlignedSize(pTmpSecHeader->Misc.VirtualSize, Alignment);
        TotalSize += tmp;
        pTmpSecHeader++;
    }
    return TotalSize;
}

// 地址换算
DWORD CImage::Rva2Raw(DWORD VirtualAddr)
{
    DWORD RawAddr = 0;
    if (VirtualAddr < m_pOptHeader->SizeOfHeaders)
    {
        RawAddr = VirtualAddr;
        return RawAddr;
    }
    PIMAGE_SECTION_HEADER pTmpSecHeader = LocateSectionByRVA(VirtualAddr);
    if (pTmpSecHeader != NULL)
    {
        RawAddr = VirtualAddr - pTmpSecHeader->VirtualAddress + pTmpSecHeader->PointerToRawData;
    }

    return RawAddr;
}

DWORD CImage::Raw2Rva(DWORD RawAddr)
{
    DWORD RvaAddr = 0;
    if (RawAddr < m_pOptHeader->SizeOfHeaders)
    {
        RvaAddr = RawAddr;
        return RvaAddr;
    }
    PIMAGE_SECTION_HEADER pTmpSecHeader = LocateSectionByRawOffset(RawAddr);
    if (pTmpSecHeader != NULL)
    {
        RvaAddr = RawAddr - pTmpSecHeader->PointerToRawData + pTmpSecHeader->VirtualAddress;
    }

    return RvaAddr;
}

VOID CImage::FormatErrorMsg(char *szPrompt, DWORD ErrCode)
{
    // 有待改进
    LPVOID lpMsgBuf;
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        ErrCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR)&lpMsgBuf,
        0,
        NULL);
    sprintf(m_szErrorMsg, "%s 错误代码:%d 原因:%s", szPrompt, ErrCode, (LPCTSTR)lpMsgBuf);
    LocalFree(lpMsgBuf);
}

VOID CImage::Cleanup()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }

    if (m_hModule != NULL)
    {
        FreePE();
    }
}

VOID CImage::InitializePEHeaders(PBYTE pBase)
{
    //解析各个PE头部结构
    m_hModule = pBase;
    m_pDosHeader = (PIMAGE_DOS_HEADER)pBase;
    m_pNtHeaders = (PIMAGE_NT_HEADERS)(pBase + m_pDosHeader->e_lfanew);
    m_pFileHeader = &m_pNtHeaders->FileHeader;
    m_SectionCnt = m_pFileHeader->NumberOfSections;
    m_pOptHeader = &m_pNtHeaders->OptionalHeader;
    m_pRelocTable = &(m_pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]);
    m_pSecHeader = (PIMAGE_SECTION_HEADER)((BYTE *)m_pOptHeader + sizeof(IMAGE_OPTIONAL_HEADER));
    m_dwEntryPoint = m_pOptHeader->AddressOfEntryPoint;
    m_TotalImageSize = m_pOptHeader->SizeOfImage;
    m_ImageBase = (ULONG_PTR)m_pOptHeader->ImageBase;

    // 导入表
    m_pImpDataDir = &m_pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    // 保存原导入表
    m_OldImpDir.VirtualAddress = m_pImpDataDir->VirtualAddress;
    m_OldImpDir.Size = m_pImpDataDir->Size;
    if (m_pImpDataDir->VirtualAddress != NULL)
    {
        m_pImportDesp = (PIMAGE_IMPORT_DESCRIPTOR)(pBase + m_pImpDataDir->VirtualAddress);
    }

    // 导出表
    m_pExpDataDir = &m_pOptHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    if (m_pExpDataDir->VirtualAddress != NULL)
    {
        m_pExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + m_pExpDataDir->VirtualAddress);
    }
}

VOID CImage::ProcessRelocTable(ULONG_PTR RelocBase)
{
    // NOTE: dll注入过程中好像没有用到??
    WORD i = 0;
    PIMAGE_BASE_RELOCATION pRelocBlock = NULL;
    if (m_pRelocTable->VirtualAddress != NULL)
    {
        pRelocBlock = (PIMAGE_BASE_RELOCATION)(m_hModule + m_pRelocTable->VirtualAddress);
        //printf("After Loaded,Reloc Table=0x%08X\n",pRelocBlock);
        do
        { //处理一个接一个的重定位块，最后一个重定位块以RAV=0结束
            //需要重定位的个数，是本块的大小减去块头的大小，结果是以DWORD表示的大小
            //而重定位数据是16位的，那就得除以2
            int numofReloc = (pRelocBlock->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / 2;
            //printf("Reloc Data num=%d\n",numofReloc);
            //重定位数据是16位的
            WORD offset = 0;
            WORD *pRelocData = (WORD *)((BYTE *)pRelocBlock + sizeof(IMAGE_BASE_RELOCATION));
            for (i = 0; i < numofReloc; i++) //循环，或直接判断*pData是否为0也可以作为结束标记
            {
                ULONG_PTR *RelocAddress = 0; //需要重定位的地址
#ifdef _WIN64
                WORD RelocFlag = IMAGE_REL_BASED_DIR64;
#else
                WORD RelocFlag = IMAGE_REL_BASED_HIGHLOW;
#endif
                //IMAGE_REL_BASED_DIR64
                //重定位的高4位是重定位类型，
                if (((*pRelocData) >> 12) == RelocFlag) //判断重定位类型是否为IMAGE_REL_BASED_HIGHLOW,x86
                {
                    //计算需要进行重定位的地址
                    //重定位数据的低12位再加上本重定位块头的RAV即真正需要重定位的数据的RAV
                    offset = (*pRelocData) & 0xFFF; //小偏移
                    RelocAddress = (ULONG_PTR *)(m_hModule + pRelocBlock->VirtualAddress + offset);
                    //对需要重定位的数据进行修正
                    //修正方法:减去IMAGE_OPTINAL_HEADER中的基址，再加上新的基址即可
                    *RelocAddress = *RelocAddress - m_pOptHeader->ImageBase + RelocBase;
                }
                pRelocData++;
            }
            //指向下一个重定位块
            pRelocBlock = (PIMAGE_BASE_RELOCATION)((char *)pRelocBlock + pRelocBlock->SizeOfBlock);

        } while (pRelocBlock->VirtualAddress);
    }
}

BOOL CImage::ProcessImportTable()
{
    BOOL bResult = TRUE;
    char szPreDirectory[MAX_PATH] = {0};
    char szCurDirectory[MAX_PATH] = {0};
    char szPrompt[256] = {0};
    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = m_pImportDesp;
    PIMAGE_THUNK_DATA NameThunk = NULL, AddrThunk = NULL;
    PIMAGE_IMPORT_BY_NAME pImpName = NULL;
    char *szImpModName = NULL;

    if (pImportDescriptor == NULL)
    {
        //无导入表，不需要处理
        return TRUE;
    }

    //更改当前路径到m_szPEPath，否则加载某些第三方dll时将找不到模块
    GetCurrentDirectoryA(MAX_PATH, szPreDirectory);
    strcpy(szCurDirectory, m_szPEPath);
    PathRemoveFileSpecA(szCurDirectory);
    SetCurrentDirectoryA(szCurDirectory);

    // 遍历每个dll
    while (pImportDescriptor->Name && pImportDescriptor->OriginalFirstThunk)
    {
        szImpModName = (char *)m_hModule + pImportDescriptor->Name;
        HMODULE hMod = LoadLibraryA(szImpModName); // 用来遍历的dll
        if (hMod == NULL)
        {
            sprintf(szPrompt, "加载导入表模块 %s 失败!", szImpModName);
            FormatErrorMsg(szImpModName, GetLastError());
            return FALSE;
        }

        NameThunk = (PIMAGE_THUNK_DATA)(m_hModule + (ULONG)pImportDescriptor->OriginalFirstThunk);
        AddrThunk = (PIMAGE_THUNK_DATA)(m_hModule + (ULONG)pImportDescriptor->FirstThunk);

        // 遍历Thunk并转成IAT
        while (NameThunk->u1.AddressOfData)
        {
            bResult = SnapThunk(hMod, szImpModName, m_hModule, NameThunk, AddrThunk);
            if (!bResult)
            {
                bResult = FALSE;
                break;
            }
            NameThunk++;
            AddrThunk++;
        }

        if (!bResult)
        {
            break;
        }
        pImportDescriptor++;
    }

    // 恢复进程的目录
    SetCurrentDirectoryA(szPreDirectory);
    return bResult;
}

//NOTE: 把INT转成 IAT了
BOOL CImage::SnapThunk(HMODULE hImpMode, char *szImpModeName, PBYTE ImageBase, PIMAGE_THUNK_DATA NameThunk, PIMAGE_THUNK_DATA AddrThunk)
{
    BOOL bResult = FALSE;
    PIMAGE_IMPORT_BY_NAME pImpName = NULL;
    DWORD dwFunAddr = 0;
    ULONG Ordinal = 0;

    // 根据最高位确定是序号还是名称
    // TODO: 这里都不考虑64位的？虽然用序号导入的情况很少.......
    if (NameThunk->u1.AddressOfData & IMAGE_ORDINAL_FLAG32)
    {
        Ordinal = IMAGE_ORDINAL(NameThunk->u1.Ordinal);
        dwFunAddr = (DWORD)GetProcAddress(hImpMode, (LPCSTR)Ordinal);
        if (dwFunAddr == 0)
        {
            sprintf(m_szErrorMsg, "无法在导入模块%s中定位导入函数:%d (序号)", szImpModeName, Ordinal);
        }
    }
    else
    {
        pImpName = (PIMAGE_IMPORT_BY_NAME)(m_hModule + (ULONG)NameThunk->u1.AddressOfData);
        dwFunAddr = (DWORD)GetProcAddress(hImpMode, (LPCSTR)pImpName->Name);
        //printf("0x%08X 按名称导入 : %s\n",dwFunAddr,pImpName->Name);
        if (dwFunAddr == 0)
        {
            sprintf(m_szErrorMsg, "无法在导入模块%s中定位导入函数:%s ", szImpModeName, pImpName->Name);
        }
    }

    if (dwFunAddr != 0)
    {
        AddrThunk->u1.Function = dwFunAddr;
        bResult = TRUE;
    }

    return bResult;
}

BOOL CImage::VerifyImage(PVOID pBase)
{
    m_pDosHeader = (PIMAGE_DOS_HEADER)pBase;
    if (m_pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
    {
        return FALSE;
    }
    m_pNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE *)pBase + m_pDosHeader->e_lfanew);
    if (m_pNtHeaders->Signature != IMAGE_NT_SIGNATURE)
    {
        return FALSE;
    }
    return TRUE;
}

LPSTR CImage::GetErrorMsg(char *szBuf, int BufSize)
{
    int len = strlen(m_szErrorMsg);
    if (len <= BufSize)
    {
        strcpy(szBuf, m_szErrorMsg);
        return szBuf;
    }
    return NULL;
}

PIMAGE_SECTION_HEADER CImage::LocateSectionByRVA(DWORD dwRVA)
{
    PIMAGE_SECTION_HEADER pTemp = m_pSecHeader;
    for (int i = 0; i < m_SectionCnt; i++)
    {
        if (pTemp->VirtualAddress <= dwRVA &&
            dwRVA < (pTemp->VirtualAddress + pTemp->Misc.VirtualSize))
        {
            return pTemp;
        }
        pTemp++;
    }
    return NULL;
}

PIMAGE_SECTION_HEADER CImage::LocateSectionByRawOffset(DWORD dwRawOffset)
{
    PIMAGE_SECTION_HEADER pTemp = m_pSecHeader;
    for (int i = 0; i < m_SectionCnt; i++)
    {
        if (pTemp->PointerToRawData <= dwRawOffset && dwRawOffset < (pTemp->PointerToRawData + pTemp->SizeOfRawData))
        {
            return pTemp;
        }
        pTemp++;
    }
    return NULL;
}

DWORD CImage::GetSectionVirtualPaddingSize(PIMAGE_SECTION_HEADER pSecHeader)
{
    DWORD AlignedSize = GetAlignedSize(pSecHeader->Misc.VirtualSize, m_pOptHeader->SectionAlignment);
    return AlignedSize - pSecHeader->Misc.VirtualSize;
}

DWORD CImage::GetSectionPhysialPaddingSize(PIMAGE_SECTION_HEADER pSecHeader)
{
    DWORD dwPaddingSize = 0;
    if (pSecHeader->Misc.VirtualSize < pSecHeader->SizeOfRawData)
    {
        dwPaddingSize = pSecHeader->SizeOfRawData - pSecHeader->Misc.VirtualSize;
    }
    else
    {
        // 节区大小大于文件该节大小，则认为没空隙
        dwPaddingSize = 0;
    }
    return dwPaddingSize;
}

BOOL CImage::MakeFileHandleWritable()
{
    BOOL bResult = FALSE;
    HANDLE hNew = INVALID_HANDLE_VALUE;
    HANDLE hProc = OpenProcess(PROCESS_DUP_HANDLE, FALSE, GetCurrentProcessId());
    if (hProc == NULL)
    {
        return FALSE;
    }
    bResult = DuplicateHandle(
        hProc,
        m_hFile,
        hProc,
        &hNew,
        GENERIC_READ,
        FALSE,
        0);

    if (bResult)
    {
        CloseHandle(m_hFile);
        m_hFile = hNew;
    }
    else
    {
        FormatErrorMsg("更改句柄权限失败", GetLastError());
    }

    CloseHandle(hProc);
    return bResult;
}

VOID CImage::AttachToMemory(PVOID pMemory)
{
    if (pMemory != NULL)
    {
        InitializePEHeaders((PBYTE)pMemory);
    }
}

BOOL CImage::AttachToProcess(HANDLE hProc, PVOID ProcessImageBase)
{
    BOOL bResult = FALSE;
    SIZE_T dwNumOfBytes = 0;
    m_hProc = hProc;
    m_ImageBase = (ULONG_PTR)ProcessImageBase;
    bResult = ReadProcessMemory(m_hProc, (LPVOID)m_ImageBase, m_HeaderData, 0x1000, &dwNumOfBytes);
    if (!bResult)
    {
        FormatErrorMsg("ReadProcessMemory失败！", GetLastError());
        return FALSE;
    }

    InitializePEHeaders(m_HeaderData);
    return bResult;
}

PIMAGE_SECTION_HEADER CImage::AddNewSectionToFile(char *szSectionName, DWORD SectionSize)
{
    PIMAGE_SECTION_HEADER pNewSecHeader = m_pSecHeader + m_SectionCnt;
    PIMAGE_SECTION_HEADER pLastSecHeader = m_pSecHeader + m_SectionCnt - 1;
    DWORD dwSectionVA, dwSectionRawOffset, dwSectionSize;

    LARGE_INTEGER liFileOffset;
    BOOL bResult;
    DWORD dwNumOfBytes;

    dwSectionVA = pLastSecHeader->VirtualAddress + GetAlignedSize(pLastSecHeader->Misc.VirtualSize, m_pOptHeader->SectionAlignment);
    dwSectionRawOffset = pLastSecHeader->PointerToRawData + GetAlignedPointer(pLastSecHeader->SizeOfRawData, m_pOptHeader->FileAlignment);
    dwSectionSize = GetAlignedSize(SectionSize, m_pOptHeader->FileAlignment);

    liFileOffset.QuadPart = dwSectionRawOffset + dwSectionSize;
    bResult = SetFilePointerEx(m_hFile, liFileOffset, NULL, FILE_BEGIN);
    if (!bResult)
    {
        FormatErrorMsg("添加新节时设置文件指针错误！", GetLastError());
        return NULL;
    }
    bResult = SetEndOfFile(m_hFile);
    if (!bResult)
    {
        FormatErrorMsg("添加新节时设置文件结束位置错误!", GetLastError());
        return NULL;
    }

    // 填充新节的SectionHeader
    ZeroMemory(pNewSecHeader, sizeof(IMAGE_SECTION_HEADER));
    strncpy((char *)pNewSecHeader->Name, szSectionName, 8);
    pNewSecHeader->Misc.VirtualSize = dwSectionSize;
    pNewSecHeader->VirtualAddress = dwSectionVA;
    pNewSecHeader->PointerToRawData = dwSectionRawOffset;
    pNewSecHeader->SizeOfRawData = dwSectionSize;
    pNewSecHeader->Characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_EXECUTE;

    m_pFileHeader->NumberOfSections += 1;
    m_SectionCnt++;

    m_pOptHeader->SizeOfImage += dwSectionSize;

    liFileOffset.QuadPart = 0;
    bResult = SetFilePointerEx(m_hFile, liFileOffset, NULL, FILE_BEGIN);
    if (!bResult)
    {
        FormatErrorMsg("添加新节保存PE时设置文件指针错误!", GetLastError());
        return NULL;
    }

    bResult = WriteFile(m_hFile, m_hModule, m_pOptHeader->SizeOfHeaders, &dwNumOfBytes, NULL);
    if (!bResult)
    {
        FormatErrorMsg("添加新节保存PE时写入文件错误!", GetLastError());
        return NULL;
    }

    FlushFileBuffers(m_hFile);
    return pNewSecHeader;
}

PIMAGE_SECTION_HEADER CImage::AddNewSectionToMemory(char *szSectionName, DWORD SectionSize)
{
    PIMAGE_SECTION_HEADER pNewSecHeader = m_pSecHeader + m_SectionCnt;
    PIMAGE_SECTION_HEADER pLastSecHeader = m_pSecHeader + m_SectionCnt - 1;
    DWORD dwSectionVA, dwSectionRawOffset, dwSectionSize;
    BOOL bResult = FALSE;
    SIZE_T dwIoCnt = 0;

    HANDLE hProc = (m_hProc == NULL) ? GetCurrentProcess() : m_hProc; // TODO: GetCurrentProcess有用？？
    ULONG_PTR HighestUserAddress = 0;
    BYTE PEHeader[0x1000] = {0};

    SYSTEM_INFO sysinfo = {0};
    GetSystemInfo(&sysinfo);
    HighestUserAddress = (ULONG_PTR)sysinfo.lpMaximumApplicationAddress;

    dwSectionVA = pLastSecHeader->VirtualAddress + ALIGN_SIZE_UP(pLastSecHeader->Misc.VirtualSize, m_pOptHeader->SectionAlignment);
    dwSectionRawOffset = pLastSecHeader->PointerToRawData + GetAlignedSize(pLastSecHeader->SizeOfRawData, m_pOptHeader->FileAlignment);
    dwSectionSize = GetAlignedSize(SectionSize, m_pOptHeader->FileAlignment);

    ULONG_PTR dwNewSectionStartAddr = m_ImageBase + dwSectionVA;
    ULONG_PTR AddressToAlloc = GetAlignedPointer(dwNewSectionStartAddr, sysinfo.dwAllocationGranularity);
    PBYTE AllocatedMem = NULL;
    for (AddressToAlloc = dwNewSectionStartAddr; AddressToAlloc < HighestUserAddress; AddressToAlloc += sysinfo.dwAllocationGranularity)
    {
        // TODO: 再看看VirtualAllocEx的文档
        AllocatedMem = (PBYTE)VirtualAllocEx(hProc, (PVOID)AddressToAlloc, dwSectionSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if (AllocatedMem != NULL)
        {
            break;
        }
    }

    if (AllocatedMem == NULL)
    {
        FormatErrorMsg("添加新节时在目标进程中申请内存失败!", GetLastError());
        return NULL;
    }

    dwSectionVA = MEM_OFFSET(AllocatedMem, m_ImageBase);

    ZeroMemory(pNewSecHeader, sizeof(IMAGE_SECTION_HEADER));
    strncpy((char *)pNewSecHeader->Name, szSectionName, 8);
    pNewSecHeader->Misc.VirtualSize = dwSectionSize;
    pNewSecHeader->VirtualAddress = dwSectionVA;
    pNewSecHeader->PointerToRawData = dwSectionRawOffset;
    pNewSecHeader->SizeOfRawData = dwSectionSize;
    pNewSecHeader->Characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_EXECUTE;

    //更新PE头中的节个数
    m_pFileHeader->NumberOfSections += 1;
    m_SectionCnt++;
    //更新PE头中的总映像大小
    m_pOptHeader->SizeOfImage += dwSectionSize;

    DWORD dwOldProtect = 0;
    bResult = VirtualProtectEx(hProc, (LPVOID)m_ImageBase, m_pOptHeader->SizeOfHeaders, PAGE_READWRITE, &dwOldProtect);
    if (!bResult)
    {
        FormatErrorMsg("修改目标进程内存属性时失败!", GetLastError());
        return NULL;
    }

    bResult = WriteProcessMemory(hProc, (LPVOID)m_ImageBase, m_HeaderData, m_pOptHeader->SizeOfHeaders, &dwIoCnt);
    if (!bResult)
    {
        FormatErrorMsg("向目标进程写入PE头数据时错误!", GetLastError());
        return NULL;
    }

    return pNewSecHeader;
}

PIMAGE_SECTION_HEADER CImage::ExtraLastSectionSizeToFile(DWORD SectionAddSize)
{
	PIMAGE_SECTION_HEADER pLastSecHeader = m_pSecHeader + m_SectionCnt  - 1;
	DWORD dwSectionNewVirtualSize,dwSectionNewRawOffset,dwSectionNewRawSize;
	DWORD dwOldSectionVirtualSize = 0 ;
	LARGE_INTEGER liFileOffset;
	BOOL bResult = FALSE ;
	DWORD dwIoCnt = 0 ;
	
	//在扩展最后一个节的情况下，需要更改最后一个节的RawSize和VirtualSize，起始偏移均不变
	//计算新节的物理大小，按文件对齐粒度对齐
	dwSectionNewRawOffset = pLastSecHeader->PointerToRawData ;
	dwSectionNewRawSize = GetAlignedSize(pLastSecHeader->SizeOfRawData + SectionAddSize,m_pOptHeader->FileAlignment);
	dwOldSectionVirtualSize = dwSectionNewVirtualSize =  GetAlignedSize(pLastSecHeader->Misc.VirtualSize , m_pOptHeader->SectionAlignment);
	//计处新节的VirtualSize大小,仅当内存大小小于文件大小时，需要增加
	if (pLastSecHeader->Misc.VirtualSize < dwSectionNewRawSize)
	{
		dwSectionNewVirtualSize += SectionAddSize;
	}
	
	//设置文件指针位置
	liFileOffset.QuadPart = dwSectionNewRawOffset +  pLastSecHeader->SizeOfRawData + SectionAddSize; //TODOL不按文件对齐？
	bResult = SetFilePointerEx(m_hFile,liFileOffset,NULL,FILE_BEGIN);
	if (!bResult)
	{
		FormatErrorMsg("添加新节时设置文件指针错误!",GetLastError());
		return NULL;
		
	}
	
	bResult = SetEndOfFile(m_hFile);
	if (!bResult)
	{
		FormatErrorMsg("添加新节时设置文件结束位置错误!",GetLastError());
		return NULL;
		
	}
	
	//填充SectionHeader
	pLastSecHeader->Misc.VirtualSize = dwSectionNewVirtualSize;
	pLastSecHeader->SizeOfRawData = dwSectionNewRawSize;
	pLastSecHeader->Characteristics |=  IMAGE_SCN_MEM_READ;
	
	//更新PE头中的总映像大小
	m_pOptHeader->SizeOfImage = m_pOptHeader->SizeOfImage - dwOldSectionVirtualSize 
		+ GetAlignedSize(pLastSecHeader->Misc.VirtualSize,m_pOptHeader->SectionAlignment);
	
	//保存PE头到文件中
	liFileOffset.QuadPart = 0;
	bResult = SetFilePointerEx(m_hFile,liFileOffset,NULL,FILE_BEGIN);
	if (!bResult)
	{
		FormatErrorMsg("添加新节保存PE时设置文件指针错误!",GetLastError());
		return NULL;
		
	}
	
	bResult = WriteFile(m_hFile,m_hModule,m_pOptHeader->SizeOfHeaders,&dwIoCnt,NULL);
	if (!bResult)
	{
		FormatErrorMsg("添加新节保存PE时写入文件错误!",GetLastError());
		return NULL;
		
	}
	
	FlushFileBuffers(m_hFile);
	return pLastSecHeader;
	
}